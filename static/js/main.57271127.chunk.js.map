{"version":3,"sources":["components/backdrop/Backdrop.js","aboutSorts/AboutBubble.js","aboutSorts/AboutHeap.js","aboutSorts/AboutInsertion.js","aboutSorts/AboutMe.js","aboutSorts/AboutMerge.js","aboutSorts/AboutQuick.js","aboutSorts/AboutSelection.js","components/Navbar/SidebarData.js","components/Navbar/Navbar.js","SortingVisualizer/SortingAlgorithms/mergeSort.js","SortingVisualizer/SortingAlgorithms/quickSort.js","SortingVisualizer/SortingAlgorithms/heapSort.js","SortingVisualizer/SortingAlgorithms/insertionSort.js","SortingVisualizer/SortingAlgorithms/selectionSort.js","SortingVisualizer/sortingvisualizer.jsx","SortingVisualizer/SortingAlgorithms/bubbleSort.js","App.js","reportWebVitals.js","index.js"],"names":["backdrop","props","className","AboutBubble","useState","modalIsOpen","setModalIsOpen","onClick","closeTimeoutMS","style","overlay","backgroundColor","content","boxShadow","background","top","bottom","left","border","right","isOpen","onRequestClose","id","target","rel","href","align","color","AboutHeap","AboutInsertion","AboutMe","AboutMerge","AboutQuick","AboutSelection","SidebarData","path","cName","Navbar","sidebar","setSideBar","showSidebar","onclick","Provider","value","to","title","map","item","index","kay","getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","i","j","push","doMerge","getQuickSortAnimations","quickSort","auxArray","lower","upper","loc_of_pivot","pivot","start","end","swap","partition","temp","getHeapSortAnimations","n","heapify","heapSort","largest","getInsertionSortAnimations","insertionSort","getSelectionSortAnimations","min","selectionSort","PRIMARY_COLOR","SECONDARY_COLOR","SECONDARY_COLOR_TWO","sortingvisualizer","handleChangeSpeed","e","setState","speed","handleChangeBars","arrayBars","resetArray","state","this","max","random","resetButtons","numOfDisabled","document","getElementsByClassName","console","log","toggleButtons","onOrOff","allOrGen","animationsLength","buttons","settingSliders","sortButtons","disabled","setTimeout","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","newHeight","height","showSwap","flag","getBubbleSortAnimations","order","indexOne","indexTwo","indexToChange","type","onChange","bubbleSort","mergeSort","idx","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.57271127.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Backdrop.css';\r\n\r\nconst backdrop = props => (\r\n    <div className=\"backdrop\"/>\r\n);\r\n\r\nexport default backdrop;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutBubble() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Bubble Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                boxShadow: '2px 2px 30px black',\r\n                                background: '#2C2C34',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div className=\"aboutSortInfo\">\r\n                        <h2 id=\"top\" className = \"titles\">Basic Concept of Bubble Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                            1. In an unsorted array, have two pointers point to the first two elements and compare them and swap into ascending order if necessary.\r\n                            <br/>\r\n                            <br/>\r\n                            2. Then, increment the two pointers and do the same comparison and swap if necessary.\r\n                            <br/>\r\n                            <br/>\r\n                            3. Repeat step 2 until the end of the array has been reached.\r\n                            <br/>\r\n                            <br/>\r\n                            4. Then, repeat steps 1-3 all over again, but this time, go until you've reached the second to last element (length - 1).\r\n                                Remember arrays start count from zero, so you'll have to subtract 1 again if you are coding it.\r\n                            <br/>\r\n                            <br/>\r\n                            5. Cool fact/trick: the reason why it's called \"bubble sort\" is because the largest element of the array will \"bubble\" its way to the end of the array.\r\n                                This explains the reasoning behind step 4 and why we only need to go to the second to last element. The last element is already the largest!\r\n                            <br/>\r\n                            <br/>\r\n                        </p>\r\n                        <h2 className=\"titles\">Pseudocode of Bubble Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            for every element \"i\" of index 0 to arrayLength-1,<br/><br/>\r\n                            &emsp;&emsp;for every element \"j\" of index 0 to arrayLength - 1 - i, (see step 5 from \"Basic Concept\" above for the intuition)<br/><br/>\r\n                            &emsp;&emsp;&emsp;&emsp;if the element at j is greater than the element after it (j+1), swap them.<br/><br/>\r\n                            &emsp;&emsp;if no swap has occured during an iteration, that means the array is sorted, and we can forgo the remaining loop, improving the time complexity.<br/><br/>\r\n                        </p>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            This sorting algorithm is easy to understand, and is a nice \"brute force\" solution. However, the time complexity is\r\n                            O(n^2) in its worst case, and is slightly improved with some modifications, which I have included in the pseudocode. You can tell through the nested for loop that, for each element for the array, iterates the whole array again.<br/><br/>\r\n                            Check out this <a className=\"link\"target='_blank' rel=\"noreferrer\" href=\"https://www.youtube.com/watch?v=o4bAoo_gFBU\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button align=\"center\" className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutBubble;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutHeap() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Heap Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#B9314F',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">Basic Concept of Heap Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                            The heap sort algorithm makes use of organizing data into a \"max heap.\"<br/><br/>\r\n                            A max heap is a binary tree, where the greatest node is located at the root.<br/><br/>\r\n                            So, given an array, we need to first turn it into a max heap tree.<br/><br/>\r\n                            1. To do this, we first need to \"heapify\" all the nodes that aren't leaf nodes. (the leaf nodes are already sorted according to max heap)<br/><br/>\r\n                                                               <div className=\"tree-example\">\r\n                                                                   (0)<br/><br/>\r\n                                                          (1)&emsp;(2)<br/><br/>\r\n                                                        (3)&nbsp; (4)&emsp;(5)&nbsp; (6)<br/><br/>\r\n                                                        </div>\r\n                            We can calculate the index of the first non-leaf node (2) by floor(num_of_nodes/2 - 1). In the above example, it's floor(7/2-1) = 2.<br/><br/>\r\n                            2. Then, we need to \"delete\" the root AND heapify the tree since we modified it. <br/><br/>\r\n                            To \"delete\" a node from an array, we can simply swap the last node with the root. In the picture above, it would swap the (0) with (6). (the first and last element of array)<br/><br/>\r\n                            3. Repeat step 2 until there are no more nodes left. Above, it should happen 3 times, for (2), (1), and (0). If done correctly, the tree should be deleted from greatest to least.<br/><br/>\r\n\r\n                            <h3 className=\"sub-headers\">How do we \"heapify\"?</h3><br/>\r\n                            1. After finding the node we want to heapify, we want to section off the node and its children and ONLY focus on those nodes (max of 3 nodes). Deleting nodes in arrays means swapping them, we also don't want to be touching the nodes that are \"deleted.\" (usually, they are towards the end of the array)<br/><br/>\r\n                            2. While we're in the subtree, let our largest value equal the root, and compare with the left and right children. Change the largest value to the a child if it is larger.<br/><br/>\r\n                            3. If the largest value has changed from the original root value, we swap the nodes at the root and where the new largest location is found.<br/><br/>\r\n                            4. Now, our subtree (max 3 nodes) has become a max heap. However, if there are grandchildren to the root we were working with, we need to recursively heapify the rest of the subtree beyond what we originally worked with.<br/><br/>\r\n\r\n                        </p>\r\n                        <h2 className=\"titles\">Pseudocode of Heap Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            // Build our max heap (reorganize our array) <br/>\r\n                            // Heapify starting from our first non-leaft node, decrement until our 0th index.<br/><br/>\r\n                            for every non-leaf node, array indices from (floor(num_of_nodes/2 -1)) to 0,<br/>\r\n                            &emsp; &emsp; heapify the node and its subtree.<br/><br/>\r\n                            for every node in our tree<br/>\r\n                            &emsp; &emsp; swap the root with the last node. (this is synonymous with \"deleting\" in a tree)<br/>\r\n                            &emsp; &emsp; heapify the array (since we modified the tree structure)<br/><br/><br/>\r\n                            // heapify function<br/>\r\n                            // this function moves the largest element in a tree to the root.<br/>\r\n                            // The size_of_tree is dynamic and changes depending on the subtree that you are currently on. Likewise, root_index depends on the subtree as well.<br/><br/>\r\n                            heapify(array, size_of_tree, root_index):<br/>\r\n                            &emsp; index_of_largest = root_index<br/>\r\n                            &emsp; left_child_of_root = 2*root_index + 1<br/>\r\n                            &emsp; right_child_of_root = 2*root_index + 2<br/><br/>\r\n\r\n                            &emsp; While the left_child_of_root is &lt; the size of the tree AND array[right_child_of_root] &gt; array[index_of_largest]<br/>\r\n                            &emsp;&emsp;&emsp; index_of_largest = left_child_of_root<br/><br/>\r\n                            \r\n                            &emsp; While the right_child_of_root is &lt; the size of the tree AND array[right_child_of_root] &gt; array[index_of_largest]<br/>\r\n                            &emsp;&emsp;&emsp; index_of_largest = right_child_of_root<br/><br/>\r\n\r\n                            &emsp;  if index_of_largest is not root_index, that means it changed,<br/>\r\n                            &emsp;&emsp;&emsp;swap the placed of the index_of_largest and the root_index<br/>\r\n                            &emsp;&emsp;&emsp;heapify(array, size_of_tree, index_of_largest)<br/><br/>\r\n                        </p>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            The heap sort algorithm is a bit complicated due to the use of trees and recursion. The time complexity of the heapify function is O(logn).\r\n                            This is because the function makes use of a bianry tree, where every node is sorted to a particular order and has 2 children.<br/>\r\n                            The time complexity of the building of the max heap of the array takes O(n) time compelxity, since there are two for loops.\r\n                            However, the heapify operations inside the for loops take O(logn) time.<br/>\r\n                            Thus, the overall time complexity would be O(2 * n * logn), which can be simplified to O(nlogn).<br/><br/>\r\n                            Check out this <a className=\"link\" target=\"_blank\" rel=\"noreferrer\" href=\"https://www.youtube.com/watch?v=Q_eia3jC9Ts\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutHeap;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutInsertion() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Insertion Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#330036',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">Basic Concept of Insertion Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                           1. Iterate through the entire array. <br/><br/>\r\n                           2. For each element, compare it with every element behind it UNTIL you've found the first element smaller than it, <br/>&emsp;OR you've reached the beginning of the array and run out of options.<br/><br/>\r\n                           3. Swap the element at the index currently being checked, and the element found meeting one or both of the conditions from step 2.<br/><br/>\r\n    \r\n\r\n                        </p>\r\n                        <h2 className=\"titles\">Pseudocode of Insertion Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            for every element i of the array,<br/>\r\n                            &emsp;let j = i.<br/>\r\n                            &emsp;while( j &gt; 0 and array[j-1] &gt; array[j])<br/>\r\n                            &emsp;&emsp;&emsp;swap(array[j-1], array[j]);<br/>\r\n                            &emsp;&emsp;&emsp;j--;<br/><br/>\r\n                        </p>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            On average, this sorting algorithm takes O(n^2). This can be explained by the for loop iterating every element, and checking elements before the index currently traversed. In the worst case, the algorithm would need to check every element before the index currently traversed.<br/><br/>\r\n                            Check out this <a className=\"link\" target=\"_blank\" href=\"https://www.youtube.com/watch?v=yCxV0kBpA6M\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" rel=\"noreferrer\"href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutInsertion;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillContacts} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutMe() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillContacts className=\"side-icon\"/> About/Contact me</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#2D1115',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">How was this website made?<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                           This website was made entirely on React! It's definitely a good beginner project for learning the basics of the technology.<br/><br/>\r\n                        </p><br/>\r\n                        <h2 className=\"titles\">About me and my Programming<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            I'm a computer science student at Cal State Fullerton. I've recently began learning about web development (as of December 2020). Prior to this, I have had some experience with Python, and I can code comfortably with C++.\r\n                        </p><br/>\r\n                        <h2 className=\"titles\">Contact Me<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            You can reach me through email at tong.johnson.28@gmail.com or on <a className=\"link\"target='_blank' rel=\"noreferrer\" href=\"https://www.linkedin.com/in/johnson-tong-11311917a\">LinkedIn</a>. Here's my <a className=\"link\"target='_blank' rel=\"nonreferrer\" href=\"https://github.com/longtongj28\">Github</a> if you'd like to check that out.\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutMe;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutMerge() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Merge Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#091540',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">Basic Concept of Merge Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                           The basic isea of merge sort is that the algorithm continually splits the array until there is only 1 element left in each subarray.<br/>\r\n                           Then, we want to merge the subarrays back together into a sorted array. Similar to quick sort, operations are done separately on the halves of the array, recursively.\r\n\r\n                        </p><br/>\r\n                        <h2 className=\"titles\">Pseudocode of Merge Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                           function mergeSort(array, auxarray, start, end)<br/>\r\n                           &emsp;&emsp; if start == end return<br/>\r\n                           &emsp;&emsp; let middle = floor(start+end/2) ~~~ how to calculate the middle index<br/><br/>\r\n                           &emsp;&emsp; mergeSort(array, auxarray, start, middle) ~~~ first half of the array<br/>\r\n                           &emsp;&emsp; mergeSort(array, auxarray, middle+1, end) ~~~ second half of the array<br/>\r\n                           &emsp;&emsp; merge(array, auxarray, start, middle, end)<br/><br/>\r\n                           function merge(array, start, middle, end)\r\n                           &emsp;&emsp; let i = start, let j = middle + 1, let k = start<br/>\r\n                           &emsp;&emsp; while ( i &lt;= middle and j &lt;= end)<br/>\r\n                           &emsp;&emsp;&emsp;&emsp; if ( array[i] &lt;= array[j] )<br/>\r\n                           &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; array[k++] = array[i++]<br/>\r\n                           &emsp;&emsp;&emsp;&emsp; else<br/>\r\n                           &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; array[k++] = auxarray[j++] <br/>\r\n                           &emsp;&emsp; while ( i &lt;= middle ) ~~~ if the second half of the array is completed <br/>\r\n                           &emsp;&emsp;&emsp;&emsp; array[k++] = auxarray[i++]<br/>\r\n                           &emsp;&emsp; while ( j &lt;= end ) ~~~ if the first half of the array is completed <br/> \r\n                           &emsp;&emsp;&emsp;&emsp; array[k++] = auxarray[j++]<br/>\r\n                        </p><br/>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            The worst case time complexity for this algorithm is O(nlogn) and the average case is also O(nlogn). Similar to quick sort, this is the result of having to split the aray continuously in half and performing operations, which is O(logn), and having to traverse subarrays to rebuild/merge into the sorted array.<br/><br/>\r\n                            Check out this <a className=\"link\" target=\"_blank\" href=\"https://www.youtube.com/watch?v=jlHkDBEumP0\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" rel=\"noreferrer\"href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutMerge;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutQuick() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Quick Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#4A6C6F',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">Basic Concept of Quick Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                           First, a pivot element must be chosen. In my implementation, I chose the first element as the pivot element. <br/><br/>\r\n                           Second, the array is partitioned until the left side of the pivot contains all elements less than the pivot element, and where the right side of the pivot has all the elements greater than it. Eventually, the pivot becomes the middle of the array.<br/><br/>\r\n                           Third, the left side and the right side of the partitioned original array are also individually partitioned and sorted so that the first element of those subarrays becomes the middle pivot element.<br/><br/>\r\n                           Recursively perform these operations until the array is sorted. Remember that the pivot element is already in its sorted position, so it doesn't need to move.\r\n                           \r\n\r\n                        </p>\r\n                        <h2 className=\"titles\">Pseudocode of Quick Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                           function quickSort( array, lower_bound, upper_bound )<br/>\r\n                            &emsp;&emsp; if (lower_bound &gt;= upper_bound) return; <br/><br/>\r\n                            &emsp;&emsp; let loc_of_pivot = partition( array, lower_bound, upper_bound )<br/>\r\n                            &emsp;&emsp; quickSort( array, lower_bound, loc_of_pivot - 1) ~~~partition from the beginning to the pivot spot<br/>\r\n                            &emsp;&emsp; quickSort( array, loc_of_pivot + 1, upper_bound ) ~~~ and partition from the pivot spot to the end<br/><br/>\r\n                            function partition(array, lower_bound, upper_bound)<br/>\r\n                            &emsp;&emsp; let pivot = auxArray[lower_bound] ~~~In my implentation I used the first element of an array be the pivot<br/>\r\n                            &emsp;&emsp; let start = lower_bound<br/>\r\n                            &emsp;&emsp; let end = upper_bound<br/><br/>\r\n                            &emsp;&emsp; while ( start &lt; end ) <br/>\r\n                            &emsp;&emsp;&emsp;&emsp; while ( array[start] &lt;= pivot ) ~~~ Starting form the left, find the first element that is greater than the pivot <br/>\r\n                            &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; start++<br/>\r\n                            &emsp;&emsp;&emsp;&emsp; while ( array[end] &gt; pivot ) ~~~ Staring from the right side of the array, find the first element that is less than the pivot  <br/>\r\n                            &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; end--<br/>\r\n                            &emsp;&emsp;&emsp;&emsp; if (start &lt; end)<br/>\r\n                            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; swap(array[start], array[end]) ~~~ start must be found before end to be swapped, so it can't be past the pivot element<br/>\r\n                            &emsp;&emsp; swap( array[lower_bound], array[end] ) ~~~~ swap the pivot element with 'end' index<br/>\r\n                            &emsp;&emsp; return end\r\n                        </p>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                           The worst case scenario for this is O(n^2, where the \"lower_bound\" above is always the greatest or smallest element. <br/>\r\n                           The partitioning is O(logn) since we split the array into two subarrays continuously and employ a divide and conquer approach.<br/>\r\n                           Thus, the average and best case is O(nlogn) time complexity, since the partitioning is O(logn) and we need to partition every element eventually.<br/><br/>\r\n                            Check out this <a className=\"link\" target=\"_blank\" href=\"https://www.youtube.com/watch?v=QN9hnmAgmOc\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" rel=\"noreferrer\"href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutQuick;","import './about.css';\r\nimport {useState} from 'react';\r\nimport Modal from 'react-modal';\r\nimport {AiOutlineClose, AiFillQuestionCircle} from 'react-icons/ai';\r\n\r\n// 1. keep backdrop 2. show aboutSort and x button to close.\r\n\r\nfunction AboutSelection() {\r\n\r\n    const [modalIsOpen, setModalIsOpen] = useState(false);\r\n\r\n    return (\r\n        <>\r\n            <button className='sortInfoButton' onClick={ () => setModalIsOpen(true) }><AiFillQuestionCircle className=\"side-icon\"/> About Selection Sort</button>\r\n            <div className=\"infoBox\">\r\n                <Modal\r\n                    closeTimeoutMS={150}\r\n                    style = {\r\n                        {\r\n                            overlay: {\r\n                                backgroundColor: 'rgba(0,0,0,0.4)'\r\n                            },\r\n                            content: {\r\n                                background: '#C57B57',\r\n                                top: '60px',\r\n                                bottom: '60px',\r\n                                left: '60px',\r\n                                border:'none',\r\n                                right: '60px',\r\n                            }\r\n                        }\r\n                    }\r\n                    isOpen={modalIsOpen} \r\n                    onRequestClose={ () => setModalIsOpen(false)}>\r\n                    <div id=\"top\" className=\"aboutSortInfo\">\r\n                        <h2  className = \"titles\">Basic Concept of Selection Sort<hr/><br/></h2>\r\n                        \r\n                        <p className = \"paragraphs\">\r\n                           1. Iterate through the entire array. <br/><br/>\r\n                           2. At the current element, compare it to every element after it.<br/><br/>\r\n                           3. If an element smaller than the current element was found, swap that element with the element currently being traversed. If the minimum is still the originally traversed element, continue onto the next element without swapping.<br/><br/>\r\n\r\n                        </p>\r\n                        <h2 className=\"titles\">Pseudocode of Selection Sort<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            for every element i of the array,<br/>\r\n                            &emsp;let min = i.<br/>\r\n                            &emsp;for every element j after i,<br/>\r\n                            &emsp;&emsp;&emsp;if there is an element smaller,<br/>\r\n                            &emsp;&emsp;&emsp;&emsp;min = j<br/>\r\n                            &emsp;if ( min != i )<br/>\r\n                            &emsp;&emsp;&emsp;swap( array[min], array[j] )<br/><br/>\r\n                        </p>\r\n                        <h2 className=\"titles\">Big O Time Complexity<hr/><br/></h2>\r\n                        \r\n                        <p className=\"paragraphs\">\r\n                            This algorithm has an O(n^2) time complexity in all cases. This is because for every element, you must check every element after it to complete an iteration. In general, this algorithm performs worse than insertion sort, although the algorithms are very similar.<br/><br/>\r\n                            Check out this <a className=\"link\" target=\"_blank\" href=\"https://www.youtube.com/watch?v=9oWd4VJOwr0\">lecture/video</a> for a much more detailed explanation on everything about this sorting algorithm.<br/><br/>\r\n                            <a className=\"link backTop\" rel=\"noreferrer\"href=\"#top\">Back to top</a>\r\n                        </p>\r\n                    </div>\r\n                    <button className=\"close-button\" onClick={ () => setModalIsOpen(false) }><AiOutlineClose color=\"#EEEEEE\" className=\"close-icon\"/></button>\r\n                </Modal>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\nexport default AboutSelection;","import React from 'react';\r\nimport AboutBubble from '../../aboutSorts/AboutBubble';\r\nimport AboutHeap from '../../aboutSorts/AboutHeap';\r\nimport AboutInsertion from '../../aboutSorts/AboutInsertion';\r\nimport AboutMe from '../../aboutSorts/AboutMe';\r\nimport AboutMerge from '../../aboutSorts/AboutMerge';\r\nimport AboutQuick from '../../aboutSorts/AboutQuick';\r\nimport AboutSelection from '../../aboutSorts/AboutSelection';\r\n\r\nexport const SidebarData = [\r\n    {\r\n        path: <AboutHeap/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutBubble/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutInsertion/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutSelection/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutQuick/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutMerge/>,\r\n        cName: 'nav-text'\r\n    },\r\n    {\r\n        path: <AboutMe/>,\r\n        cName: 'nav-text'\r\n    },\r\n];","import React, {useState} from 'react'\r\nimport Backdrop from '../backdrop/Backdrop';\r\nimport {Link} from 'react-router-dom';\r\nimport {AiOutlineClose,AiOutlineInfoCircle} from 'react-icons/ai';\r\nimport { SidebarData } from './SidebarData';\r\nimport {IconContext} from 'react-icons';\r\nimport './Navbar.css';\r\n\r\nfunction Navbar() {\r\n    const [sidebar, setSideBar] = useState(false);\r\n    \r\n\r\n    const showSidebar = () => {\r\n        setSideBar(!sidebar);\r\n    }\r\n\r\n    let backdrop;\r\n    if (sidebar) {\r\n        backdrop = <Backdrop onclick={showSidebar}/>;\r\n    }\r\n    \r\n    return (\r\n        <>\r\n        <IconContext.Provider value={{ color: '#fff' }}>\r\n            {backdrop}\r\n            <div className=\"navbar\">\r\n                <Link to=\"#\" className='menu-bars'>\r\n                    <AiOutlineInfoCircle title=\"Learn more about the site and the algorithms\" color=\"white\"className='settings-icon' onClick={showSidebar}/>\r\n                </Link>\r\n            </div> \r\n            <nav className={sidebar ? 'nav-menu active':'nav-menu'}>\r\n                <ul className='nav-manu-items'>\r\n                    <li className =\"navbar-toggle\">\r\n                        <Link to=\"#\">\r\n                            <AiOutlineClose className='close' onClick={showSidebar}/>\r\n                        </Link>\r\n                    </li>\r\n                    <div className=\"menu-items\">\r\n                        {SidebarData.map( (item, index) => {\r\n                            return (\r\n                                <li kay={index} className={item.cName}>\r\n                                    {item.path}\r\n                                </li>\r\n                            )\r\n                        })}\r\n                    </div>\r\n                </ul>\r\n            </nav> \r\n            </IconContext.Provider>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default Navbar\r\n","export function getMergeSortAnimations(array) \r\n{\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n}\r\n  \r\nfunction mergeSortHelper(\r\n  mainArray,\r\n  startIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  if (startIdx === endIdx) return;\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(\r\n  mainArray,\r\n  startIdx,\r\n  middleIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  let k = startIdx;\r\n  let i = startIdx;\r\n  let j = middleIdx + 1;\r\n  \r\n  // loop until one subarray has been looped through\r\n  while (i <= middleIdx && j <= endIdx) {\r\n    // show animations before comparison occurs\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, j]);\r\n\r\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n\r\n      // in animations, at index k we will need to change the value of the bar\r\n      // to aux(j)\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      animations.push([i, j]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    } else {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      animations.push([i, j]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n    \r\n  }\r\n\r\n  // if the second half of the array is completed\r\n  while (i <= middleIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, i]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index i in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[i]]);\r\n    animations.push([i, i]);\r\n    mainArray[k++] = auxiliaryArray[i++];\r\n  \r\n  }\r\n  // if the first half of the array is completed\r\n  while (j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([j, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    \r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index j in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[j]]);\r\n    animations.push([j, j]);\r\n\r\n    mainArray[k++] = auxiliaryArray[j++];\r\n  }\r\n}\r\n","export function getQuickSortAnimations( array ) {\r\n    const animations = [];\r\n\r\n    let n = array.length;\r\n\r\n    let lower = 0;\r\n    let upper = n - 1;\r\n    \r\n    quickSort( array, lower, upper, animations ); \r\n\r\n    return animations;\r\n}\r\n\r\nfunction quickSort( auxArray, lower, upper, animations )\r\n{\r\n    if ( lower >= upper ) return;\r\n    \r\n\r\n    let loc_of_pivot = partition(auxArray, lower, upper, animations);\r\n    quickSort( auxArray, lower, loc_of_pivot -1, animations );          // looks something like this: [......loc_of_pivot......]\r\n    quickSort( auxArray, loc_of_pivot + 1, upper, animations );        // no need to mess with the pivot anymore, it's in the right spot\r\n}\r\n\r\nfunction partition(auxArray, lower, upper, animations) {\r\n    let pivot = auxArray[lower];\r\n    let start = lower; // index where the first element that is greater than the pivot is from the left\r\n    let end = upper;   // index where the first element that is less than the pivot is from the right\r\n\r\n\r\n    while ( start < end )\r\n    {\r\n        while ( auxArray[start] <= pivot ) // traverse along the auxArray from left to right until found element greater than pivot\r\n        {\r\n\r\n            start++;\r\n        }\r\n\r\n        while ( auxArray[end] > pivot ) // traverse along the auxArray from right to left until found element less than pivot\r\n        {\r\n            end--;\r\n        }\r\n\r\n        if ( start < end )\r\n        {\r\n            animations.push( [start, end] );\r\n            animations.push( [start, auxArray[end] ] );\r\n            animations.push( [end, auxArray[start] ] );\r\n            animations.push( [start, end] );\r\n\r\n            swap( auxArray, start, end ); // start must be found before end\r\n        }\r\n    }\r\n    animations.push( [lower, end] );\r\n    animations.push( [lower, auxArray[end] ] );\r\n    animations.push( [end, auxArray[lower] ] );\r\n    animations.push( [lower, end] );\r\n    \r\n    swap( auxArray, lower, end ); // swap the pivot element with the 'end' index\r\n\r\n    return end;\r\n}\r\n\r\nexport function swap( auxArray, start, end ) \r\n{\r\n    let temp = auxArray[start];\r\n    auxArray[start] = auxArray[end];\r\n    auxArray[end] = temp;\r\n}","import {swap} from './quickSort';\r\n\r\nexport function getHeapSortAnimations(array) {\r\n    const animations = [];\r\n\r\n    let n = array.length;\r\n   \r\n    heapSort(array, n, animations);\r\n    return animations;\r\n}\r\n//using max heap concept to sort\r\nfunction heapSort(array, n, animations)\r\n{\r\n  \r\n  //first we have to build the max heap based tree\r\n  //start at the first node that isn't a leaf node.\r\n  for (let i = Math.floor(n/2-1); i >= 0; i--)\r\n  {\r\n    heapify(array, n, i, animations);\r\n  }\r\n  //Next, we have to \"delete\" all of the nodes on the tree, starting from the root.\r\n  //To do so, we swap the \"last\" node with the root.\r\n  //While doing so, we want to make sure the remaining nodes are in max heap conditions.\r\n  for ( let i = n-1; i > 0; i--)\r\n  {\r\n    animations.push( [ 0, i ] );\r\n    animations.push( [ 0, array[i] ] );\r\n    animations.push( [ i, array[0] ] );\r\n    animations.push( [ 0, i ] );\r\n\r\n    swap(array, 0, i);\r\n    heapify(array, i, 0, animations);\r\n  }\r\n}\r\n\r\n// moves the largest element in a tree to the root\r\nfunction heapify(array, n, i, animations)\r\n{\r\n  let largest = i;\r\n  let left = 2*i + 1;\r\n  let right = 2*i + 2;\r\n\r\n\r\n  while ( left < n && array[left] > array[largest] )\r\n  {\r\n    largest = left;\r\n  }\r\n\r\n  while ( right < n && array[right] > array[largest] )\r\n  {\r\n    largest = right;\r\n  }\r\n  let heapSwaps = [];\r\n  if (largest !==  i)\r\n  {\r\n    animations.push( [ largest, i ] ); // on\r\n    animations.push( [ largest, array[i] ] ); // swap\r\n    animations.push( [ i, array[largest] ] );\r\n    animations.push( [ largest, i ] ); // off\r\n    swap( array, largest , i);\r\n\r\n    heapify( array, n, largest, animations);\r\n  }\r\n}\r\n\r\n","import {swap} from './quickSort';\r\n\r\nexport function getInsertionSortAnimations(array) {\r\n    const animations = [];\r\n    insertionSort( array, animations );\r\n    return animations;\r\n  }\r\n\r\n  function insertionSort( array, animations )\r\n  {\r\n    let n = array.length;\r\n    for ( let i = 1; i < n; i ++)\r\n    {\r\n      let j = i;\r\n\r\n      while ( j > 0 && array[j-1] > array[j])\r\n      {\r\n        animations.push( [ j-1, j ] );\r\n        animations.push( [ j-1, array[j] ] );\r\n        animations.push( [ j, array[j-1] ] );\r\n        animations.push( [ j-1, j ] );\r\n        swap( array, j - 1 , j);\r\n        j--;\r\n      }\r\n    }\r\n  }","import {swap} from './quickSort';\r\n\r\nexport function getSelectionSortAnimations(array) {\r\n    const animations = [];\r\n    selectionSort( array, animations );\r\n    return animations;\r\n}\r\n\r\nfunction selectionSort( array, animations )\r\n{\r\n    let n = array.length;\r\n\r\n    for ( let i = 0; i < n-1; i++)\r\n    {\r\n        let min = i;\r\n        for (let j = i + 1; j < n; j++)\r\n        {\r\n            if (array[j] < array[min]) min = j;\r\n        }\r\n        if (min !== i)\r\n        {\r\n            animations.push( [i, min]);\r\n            animations.push( [ i, array[min] ]);\r\n            animations.push( [ min, array[i] ]);\r\n            animations.push( [i, min]);\r\n            swap(array, i, min);\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport './sortingvisualizer.css';\r\nimport Navbar from '../components/Navbar/Navbar';\r\nimport { BrowserRouter as Router} from 'react-router-dom';\r\nimport {getMergeSortAnimations} from  './SortingAlgorithms/mergeSort.js';\r\nimport {getBubbleSortAnimations} from  './SortingAlgorithms/bubbleSort.js';\r\nimport {getHeapSortAnimations} from  './SortingAlgorithms/heapSort.js';\r\nimport {getQuickSortAnimations} from  './SortingAlgorithms/quickSort.js';\r\nimport {getInsertionSortAnimations} from './SortingAlgorithms/insertionSort.js';\r\nimport {getSelectionSortAnimations} from './SortingAlgorithms/selectionSort';\r\nimport {AiFillGithub} from 'react-icons/ai';\r\nimport {FaStopCircle} from 'react-icons/fa';\r\n\r\n \r\n// Change this value for the number of bars (value) in the array.\r\n\r\n// This is the main color of the array bars.\r\nconst PRIMARY_COLOR = '#DAD2BC';\r\n\r\n// This is the color of array bars that are being compared throughout the animations.\r\nconst SECONDARY_COLOR = '#2EBFA5';\r\n\r\nconst SECONDARY_COLOR_TWO = '#C5D86D';\r\n\r\n\r\nexport default class sortingvisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            array: [],\r\n            arrayBars: 50,\r\n            speed: 30,\r\n        };\r\n    }\r\n    handleChangeSpeed = (e) => {\r\n        this.setState({speed: e.target.value})\r\n    }\r\n    handleChangeBars = (e) => {\r\n        this.setState( {arrayBars: e.target.value} );\r\n        this.resetArray();\r\n    }\r\n\r\n    componentDidMount() \r\n    {\r\n        this.resetArray();\r\n    }\r\n\r\n    resetArray() \r\n    {\r\n        const array = [];\r\n        for (let i = 0; i < this.state.arrayBars; i++) {\r\n            array.push(randomIntBetween(7,550));\r\n        }\r\n        this.setState({array});\r\n\r\n        let numOfDisabled = document.getElementsByClassName(\"btn disabled\").length;\r\n        console.log(numOfDisabled);\r\n        let resetButtons;\r\n        if (numOfDisabled > 0) resetButtons = true; \r\n        this.toggleButtons(resetButtons,\"all\");\r\n    }\r\n\r\n    toggleButtons(onOrOff, allOrGen, animationsLength) {\r\n        const buttons = document.getElementsByClassName('btn disabled');\r\n        const settingSliders = document.getElementsByClassName(\"slider\");\r\n        if (onOrOff === false) {\r\n            const sortButtons = document.getElementsByClassName(\"btn sort\");\r\n            while (sortButtons.length > 0) {\r\n                sortButtons[0].className = \"btn disabled\";\r\n            }\r\n            for (let i = 0; i < settingSliders.length; i++)\r\n            {\r\n                settingSliders[i].disabled = true;\r\n            }\r\n            const genArrayButton = document.getElementsByClassName('btn');\r\n            genArrayButton[0].className = \"btn disabled\";\r\n        }\r\n        else if (onOrOff === true && allOrGen === 'gen') {\r\n            setTimeout( () => {\r\n                buttons[0].className = \"btn\";\r\n                for (let i = 0; i < settingSliders.length; i++)\r\n                {\r\n                    settingSliders[i].disabled = false;\r\n                }\r\n            }, animationsLength * this.state.speed)\r\n        }\r\n        else if (onOrOff === true && allOrGen === \"all\") {\r\n            while (buttons.length > 0) {\r\n                buttons[0].className = \"btn sort\";\r\n            }\r\n        }\r\n    }\r\n\r\n    // sorts\r\n    // The array animation arrays are ordered like this: [index1, heightofindex2, index2, heightofindex1].\r\n    mergeSort() \r\n    {\r\n        const animations = getMergeSortAnimations(this.state.array);\r\n\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n\r\n        for (let i = 0; i < animations.length; i++) \r\n        {\r\n          const arrayBars = document.getElementsByClassName('array-bar');\r\n          const isColorChange = (i % 3 === 0 || i % 3 === 2);\r\n          if (isColorChange) \r\n          {\r\n            const [barOneIdx, barTwoIdx] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIdx].style;\r\n            const barTwoStyle = arrayBars[barTwoIdx].style;\r\n            if ( i%3 === 0)\r\n            {\r\n                setTimeout(() => {\r\n                barOneStyle.backgroundColor = SECONDARY_COLOR;\r\n                barTwoStyle.backgroundColor = SECONDARY_COLOR_TWO;\r\n                }, i * this.state.speed);\r\n            }\r\n            if (i%3 === 2)\r\n            {\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = PRIMARY_COLOR;\r\n                    barTwoStyle.backgroundColor = PRIMARY_COLOR;\r\n                    }, i * this.state.speed);\r\n            }\r\n          }\r\n          else \r\n          {\r\n            setTimeout(() => {\r\n              const [barOneIdx, newHeight] = animations[i];\r\n              const barOneStyle = arrayBars[barOneIdx].style;\r\n              barOneStyle.height = `${newHeight}px`;\r\n            }, i * this.state.speed);\r\n          }\r\n        }\r\n    }\r\n\r\n    quickSort() \r\n    {\r\n        const animations = getQuickSortAnimations(this.state.array);\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n        this.showSwap(animations);\r\n    }\r\n\r\n    bubbleSort() \r\n    {\r\n        const animations = getBubbleSortAnimations(this.state.array);\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n\r\n        for (let i = 0; i < animations.length; i++) \r\n        {\r\n          const arrayBars = document.getElementsByClassName('array-bar');\r\n          const isColorChange = (i % 4 === 0) || (i % 4 === 3); // if first or second value of animations, proceed\r\n\r\n          if (isColorChange) \r\n          {\r\n            const [barOneIdx, barTwoIdx] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIdx].style;\r\n            const barTwoStyle = arrayBars[barTwoIdx].style;\r\n           \r\n            if (i%4 === 0)\r\n            {\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = SECONDARY_COLOR;\r\n                    barTwoStyle.backgroundColor = SECONDARY_COLOR_TWO;\r\n                }, i * this.state.speed);\r\n            }\r\n\r\n            if (i%4 === 3)\r\n            {\r\n                setTimeout(() => {\r\n                    barOneStyle.backgroundColor = PRIMARY_COLOR;\r\n                    barTwoStyle.backgroundColor = PRIMARY_COLOR;\r\n                }, i * this.state.speed);\r\n            }\r\n          }\r\n\r\n          else if ( (i % 4 === 1 ||  i % 4 === 2) && animations[i] !== 'no swap')  // if third or fourth value AND swapping occured, change the bars\r\n          {              \r\n            const [barOneIdx, newHeight] = animations[i];\r\n\r\n            setTimeout(() => {\r\n              const barOneStyle = arrayBars[barOneIdx].style;\r\n              barOneStyle.height = `${newHeight}px`;\r\n            }, i * this.state.speed);\r\n          }\r\n        }\r\n        \r\n    }\r\n\r\n    heapSort() {\r\n        const animations = getHeapSortAnimations(this.state.array);\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n        this.showSwap(animations);\r\n    }\r\n\r\n    insertionSort() {\r\n        const animations = getInsertionSortAnimations(this.state.array);\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n        this.showSwap(animations);\r\n    }\r\n\r\n    selectionSort() {\r\n        const animations = getSelectionSortAnimations(this.state.array);\r\n        this.toggleButtons(false);\r\n        this.toggleButtons(true,\"gen\", animations.length);\r\n        this.showSwap(animations);\r\n    }\r\n\r\n    showSwap(animations) {\r\n        for ( let i = 0; i < animations.length; i++)\r\n        {\r\n            const arrayBars = document.getElementsByClassName('array-bar');\r\n            let order = i%4;\r\n            if (order === 0)\r\n            {\r\n                let indexOne = animations[i][0];\r\n                let indexTwo = animations[i][1];\r\n                \r\n                setTimeout( () => {\r\n                    arrayBars[indexOne].style.backgroundColor = SECONDARY_COLOR;\r\n                    arrayBars[indexTwo].style.backgroundColor = SECONDARY_COLOR_TWO;\r\n                }, i * this.state.speed);\r\n            }\r\n            else if (order === 3)\r\n            {\r\n                let indexOne = animations[i][0];\r\n                let indexTwo = animations[i][1];\r\n\r\n                setTimeout( () => {\r\n                    arrayBars[indexOne].style.backgroundColor = PRIMARY_COLOR;\r\n                    arrayBars[indexTwo].style.backgroundColor = PRIMARY_COLOR;\r\n                }, i * this.state.speed);\r\n            }\r\n            else if ( order === 1|| order === 2 )\r\n            {\r\n                let indexToChange = animations[i][0];\r\n                let newHeight = animations[i][1];\r\n\r\n                setTimeout( () => {\r\n                    arrayBars[indexToChange].style.height = `${newHeight}px`;\r\n                }, i * this.state.speed);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {array} = this.state;\r\n\r\n        return (\r\n            [\r\n            <header className=\"top\">\r\n                <button title=\"Stop animation and reset array\" className=\"stop-button\"><a id=\"stop-link\" href=\"/\"><FaStopCircle id=\"stop-icon\"/></a></button>\r\n                <div className =\"speedSlider\">\r\n                    <div className=\"name-slider\">Speed</div>\r\n                        <input title=\"Drag left to make animation faster\" className=\"slider\" type=\"range\" min={1} max ={100}value={this.state.speed} onChange={this.handleChangeSpeed}/>\r\n                </div>\r\n                <div className=\"barSlider\">\r\n                    <div className=\"name-slider\">Bars</div>\r\n                        <input title=\"Drag right to increase the number of bars\" className=\"slider\" type=\"range\" min={10} max ={70}value={this.state.arrayBars} onChange={this.handleChangeBars}/>\r\n                </div>\r\n                <Router>\r\n                    <Navbar/>\r\n                </Router>\r\n                <a id=\"github-link\" target =\"_blank\" rel = \"nonreferrer\" href= \"https://github.com/longtongj28/sorting-visualizer\"><AiFillGithub title=\"Github Repository for the site\"id=\"github-icon\"/></a>\r\n                <a className=\"homelink\" href='/'></a>\r\n                <h1 id = \"title\">Sorting Algorithms</h1>\r\n                <div className = \"button-bar\">\r\n                    <button className=\"btn\" onClick = {() => this.resetArray()}> Generate New Array</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.quickSort()}>Quick Sort</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.bubbleSort()}>Bubble Sort</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.mergeSort()}>Merge Sort</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.heapSort()}>Heap Sort</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.insertionSort()}>Insertion Sort</button>\r\n                    <button className=\"btn sort\" onClick = {() => this.selectionSort()}>Selection Sort</button>\r\n                </div>\r\n            </header>,\r\n\r\n            <div className=\"array-container\">\r\n            {array.map( (value, idx) => (\r\n                <div\r\n                    className=\"array-bar\"\r\n                    key={idx}\r\n                    style={{\r\n                        height: `${value}px`,\r\n                        backgroundColor: PRIMARY_COLOR,\r\n                    }}\r\n                ></div>\r\n            ))}\r\n            </div>\r\n                ]\r\n        );\r\n    }\r\n}\r\n\r\nfunction randomIntBetween( min, max ) {\r\n    return Math.floor(Math.random() * (max - min + 1 ) + min);\r\n}","export function getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    let n = array.length;\r\n    for (let i = 0; i < n-1; i++)\r\n    {\r\n        let flag = 0; // changes to 1 if swap occurs\r\n        for (let j = 0; j < n-1- i; j++)\r\n        {\r\n            //before comparing array[j] and j+1, color them and uncolor them\r\n            animations.push( [j, j+1] );\r\n            \r\n\r\n            if ( array[j] > array[j+1] )\r\n            {\r\n                \r\n                animations.push( [ j, array[j+1] ] );\r\n                animations.push( [ j+1, array[j] ] ); //in main code, change the arrayBar[j] to the pixel value of auxarr\r\n                let temp = array[j];\r\n                array[j] = array[j+1];\r\n                array[j+1] = temp;\r\n                flag = 1;\r\n            }\r\n            else if ( array[j] <= array[j+1] ) {\r\n                animations.push('no swap'); //placeholder if no value is swapped \r\n                animations.push('no swap');\r\n            } \r\n            animations.push( [j, j+1] ); \r\n        }\r\n        if (flag === 0) break; //no swap occured, end the loop, the array is sorted.\r\n    }\r\n    return animations;\r\n  }","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/sortingvisualizer';\nimport './App.css';\n\n\nfunction App() {\n  return (\n    <>\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n\n    \n      \n    </>\n  ); \n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}